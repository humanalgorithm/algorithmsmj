{% extends 'base.html' %}


{% block jumbotron %}
{% include 'navbar.html' %}
<!-- Main jumbotron for a primary marketing message or call to action -->
<div class="jumbotron">
    <div class="container">
        <div class="row">
            <div class="col-md-7"></div>
            <div class="col-md-8">
                <p1> Merge Sort is an O(n log(n)) algorithm that recursively divdes an array into sorted subsets and
                    then merges them back together. Merge sort uses three position holders to accomplish this, low
                    element, high element
                    and middle element. Each time merge sort calls itself it will call merge sort with low element to
                    middle element and merge sort with middle element + 1 to the high element. The base case for merge
                    sort is when the
                    array to sort is of length 1. From here it will call the merge function where it will pass in two
                    arrays and then merge them.

                    <br><br> Merge sort being one of the more efficient algorithms is very useful in production
                    applications. The downside of merge sort that it can require a lot of memory if an in place
                    implementation is not used.
                </p1>
                <p1><a class="btn btn-primary btn-lg" href="#sortutility" role="button">Use Merge Sort &raquo;</a></p1>
            </div>
        </div>

    </div>
</div>


{% endblock %}

{% block content %}
<a name="sortutility"><h1 style="padding-top: 40px; margin-top: -40px;"></h1></a>
{% include 'sortutility.html' %}
{% include 'mergesortbutton.html' %}
<div class="row">
    <div class="col-md-1"></div>

    <div class="col-md-10">
<pre> <code>
    #with comments
    def mergeSort(arrayIn):

    #initialize left array variable to pass to mergesort
    leftArrayPass = []
    #initialize right array variable to pass to mergesort
    rightArrayPass = []

    #initialize low element position
    lo = 0
    #initialize high element position
    hi = len(arrayIn)-1
    #initialize middle element position
    mid = (lo + hi)/2
    i=0
    #initialize starting lower point for right array
    r=mid+1
    #build left array from 0 to middle element
    while i <= mid:
    leftArrayPass.append(arrayIn[i])
    i=i+1
    #build right array from right start to high element
    while r <= hi:
    rightArrayPass.append(arrayIn[r])
    r=r+1

    #if the base case of one element remains has not been reached
    if(len(arrayIn))> 1:

    #split into two arrays left and right by recursively calling merge sort on left array and right array then get
    return
    #get left array by passing in left array and breaking it down recursively
    leftArray = mergeSort(leftArrayPass)

    #get right array by passing in right array and breaking it down recursively
    rightArray = mergeSort(rightArrayPass)

    #take the return of left array and right array and then merge them
    arrayReturn = mergeSets(leftArray, rightArray)

    #return back to calling function the merged sorted sets
    return arrayReturn

    #from the base case, else return if array is one element long
    else:
    return arrayIn

    #take two arrays and merge them into sorted order
    def mergeSets(leftArray, rightArray):
    #initialize array that will be returned once merging is done
    returnArray = []

    #initializej counter for left array
    i=0
    #initializze counter for right array
    j=0
    #initialize counter for looping through the total number of elements
    k=0
    #precalculate the size or the return array by getting the length of the passed in left array and right array
    returnSize = len(leftArray) + len(rightArray)

    #initialize reteurn array with all 0's
    for x in range (0, returnSize):
    returnArray.append(0)

    '''
    go through both the left array and the right array, append elements to the return array that is less by comparing
    the elements in the left array and the right array sometimes the loop will exaust all of the elements in the left
    array or the right array before pulling elements from the other array so we need to check to see if we are have
    exausted the other array at each pass.
    '''
    while k < returnSize:
    #If I and J not empty compare
    #if left array and right array hasn't been exasuted
    if i < len (leftArray) and j < len(rightArray):
    #if left array element is less than right element than append left array element
    if leftArray[i] < rightArray [j]:
    #append left array element to return array
    returnArray[k] = leftArray[i]
    i+=1
    #otherwise append right array element to return array
    else:
    returnArray[k] = rightArray[j]
    j+=1

    #if left array hasn't been exausted and right array has then append left array element
    elif i < len(leftArray) and j>=len(rightArray):
    returnArray[k] = leftArray[i]
    i+=1

    #if left array has been exausted and right array hasn't then append right array element
    elif i>=len(leftArray) and j < len(rightArray):
    returnArray[k] = rightArray[j]
    j+=1

    #if both arrays have been exausted then break out of loop
    elif i>=len(leftArray) and j>=len(rightArray):
    break
    k+=1
    return returnArray

</code></pre>
        <br>
 <pre> <code>
     #without comments
     def mergeSort(arrayIn):

     leftArrayPass = []
     rightArrayPass = []

     lo = 0
     hi = len(arrayIn)-1
     mid = (lo + hi)/2
     i=0

     r=mid+1
     while i <= mid:
     leftArrayPass.append(arrayIn[i])
     i=i+1
     while r <= hi:
     rightArrayPass.append(arrayIn[r])
     r=r+1

     if(len(arrayIn))> 1:

     leftArray = mergeSort(leftArrayPass)
     rightArray = mergeSort(rightArrayPass)
     arrayReturn = mergeSets(leftArray, rightArray)

     return arrayReturn
     else:
     return arrayIn

     def mergeSets(leftArray, rightArray):

     returnArray = []

     i=0
     j=0
     k=0
     returnSize = len(leftArray) + len(rightArray)
     for x in range (0, returnSize):
     returnArray.append(0)

     while k < returnSize:
     if i < len(leftArray) and j < len(rightArray):
     if leftArray[i] < rightArray[j]:
     returnArray[k] = leftArray[i]
     i+=1
     else:
     returnArray[k] = rightArray[j]
     j+=1
     elif i < len(leftArray) and j>=len(rightArray):
     returnArray[k] = leftArray[i]
     i+=1
     elif i>=len(leftArray) and j < len(rightArray):
     returnArray[k] = rightArray[j]
     j+=1
     elif i>=len(leftArray) and j>=len(rightArray):
     break
     k+=1
     return returnArray

 </code></pre>
    </div>
    <div class="col-md-1"></div>
</div>

{% include 'table.html' %}


{% endblock %}